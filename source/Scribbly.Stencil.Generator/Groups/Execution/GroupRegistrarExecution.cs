using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Scribbly.Stencil.Endpoints.Context;

namespace Scribbly.Stencil.Groups;

public class GroupRegistrarExecution
{
    private class GroupItem
    {
        public string? GroupName { get; set; }
        public TargetGroupCaptureContext? Context { get; set; }

        public List<GroupItem> Children { get; set; } = [];

        public bool IsParent => Children.Any();
        public GroupItem(string groupName)
        {
            GroupName = groupName;
        }
        
        public GroupItem(string groupName, TargetGroupCaptureContext? context)
        {
            GroupName = groupName;
            Context = context;
        }
        
        public GroupItem(string groupName, TargetGroupCaptureContext context, List<GroupItem> children)
        {
            GroupName = groupName;
            Context = context;
            Children = children;
        }
        
    }
    
    private static GroupItem GetOrCreateNode(ConcurrentDictionary<string, GroupItem> map, string id, TargetGroupCaptureContext? context)
    {
        return map.AddOrUpdate(id,
            (key) => new GroupItem(key, context),
            (k, v) =>
            {
                if (context is null)
                {
                    return v;
                }
                return new GroupItem(k, context);
            });
        // if (map.TryGetValue(id, out var existing))
        // {
        //     existing.Context = context;
        //     return existing;
        // }
        //
        // var node = new GroupItem(id, context);
        // map.Add(id, node);
        //
        // return node;
    }

    private static ConcurrentDictionary<string, GroupItem>? CreateTree(ImmutableArray<TargetGroupCaptureContext> groups)
    {
        if (groups.IsDefaultOrEmpty)
        {
            return null;
        }
        
        if (groups.IsDefaultOrEmpty)
        {
            return null;
        }

        var map = new ConcurrentDictionary<string, GroupItem>();  
        
        foreach (var group in groups)
        {
            if (group.MemberOf is null)
            {
                GetOrCreateNode(map, $"{group.Namespace}.{group.TypeName}", group);
            }
            else
            {
                GetOrCreateNode(map, group.MemberOf, null).Children.Add(GetOrCreateNode(map, $"{group.Namespace}.{group.TypeName}", group));
            }
        }
        
        return map; // Return the root node
    }
    
    public static void Generate(SourceProductionContext context, (ImmutableArray<TargetMethodCaptureContext> Endpoints, ImmutableArray<TargetGroupCaptureContext> Groups) tree)
    {
        var (endpoints, groups) = tree;

        var groupDictionary = CreateTree(groups);
        
        if (groups.IsDefaultOrEmpty)
            return;

        var sb = new StringBuilder($$"""
                                     // <auto-generated/> @{{DateTime.UtcNow}}
                                     #nullable enable

                                     using System;
                                     using Microsoft.AspNetCore.Builder;
                                     using Microsoft.AspNetCore.Http;
                                     using Microsoft.AspNetCore.Mvc;
                                     using Microsoft.AspNetCore.Routing;
                                     
                                     {{GroupUsingStatements(groups)}}

                                     public static class GroupRegistrationExtensions
                                     {
                                         public static global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder MapApplicationEndpoints(this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder app)
                                         {                            
                                     """);

        if (groupDictionary is not null)
        {
            DebugTree(sb, groupDictionary, true);
            
            foreach (var group in groupDictionary)
            {
                if (!group.Value.IsParent)
                {
                    continue;
                }
                sb.AppendLine(
                    $"""
                            var {group.Value.GroupName?.Replace(".", "")}RouteGroup = app.Map{group.Value.Context?.TypeName}();
                     """);
                foreach (var child in group.Value.Children)
                {
                    sb.AppendLine(
                        $"""
                                {group.Value.GroupName?.Replace(".", "")}RouteGroup.Map{group.Value.Context?.TypeName}();
                         """);
                }
            }
        }
        
        foreach (var endpoint in endpoints)
        {
            var methodName = endpoint.MemberOf ?? "app";
            
            sb.AppendLine($"// {methodName}.Map{endpoint.TypeName}()");
        }

        sb.AppendLine("""
                                return app;
                            }
                      }
                      """);
        context.AddSource($"Registrar.Scribbly.Stencil.GroupRegistry.g.cs", sb.ToString());
    }


    private static string GroupUsingStatements(ImmutableArray<TargetGroupCaptureContext> groups)
    {
        var builder = new StringBuilder();
        foreach (var group in groups.Select(g => g.Namespace).Distinct())
        {
            builder.AppendLine($"using {group};");
        }
        
        return builder.ToString();
    }

    private static StringBuilder DebugTree(StringBuilder sb, ConcurrentDictionary<string, GroupItem> groupDictionary, bool enable)
    {
        if (!enable)
        {
            return sb;
        }
        foreach (var group in groupDictionary)
        {
            sb.AppendLine();
            sb.AppendLine(
                $"// ----> KEY: {group.Key} NAME: {group.Value.GroupName} TYPE: {group.Value.Context?.TypeName}");
            foreach (var valueChild in group.Value.Children)
            {
                sb.AppendLine(
                    $"//          ---------------> CHILD: {valueChild.GroupName} TYPE: {valueChild.Context?.TypeName}");

                if (valueChild.IsParent)
                {
                    foreach (var childsChild in valueChild.Children)
                    {
                        sb.AppendLine(
                            $"//          ------------------------> CHILD Of CHILD: {childsChild.GroupName} TYPE: {childsChild.Context?.TypeName}");
                    }
                }
            }
        }
        
        return sb;
    }
}