using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Scribbly.Stencil.Builder.Context;
using Scribbly.Stencil.Endpoints;
using Scribbly.Stencil.Endpoints.Factories;
using Scribbly.Stencil.Groups.Factories;

namespace Scribbly.Stencil.Groups;

public static class GroupExtensionsExecution
{
    /// <summary>
    /// Writes the captured information about the handle method as a Minimal API endpoint.
    /// </summary>
    /// <param name="context">Generator Context</param>
    /// <param name="capture">Captured Group combined with the endpoints Context</param>
    public static void Generate
        (SourceProductionContext context, 
        ((TargetGroupCaptureContext Group, BuilderCaptureContext? Builder) GroupContext, ImmutableArray<TargetMethodCaptureContext> Endpoints) capture)
    {
        var (subject, builder) = capture.GroupContext;

        var endpoints = capture.Endpoints
            .Where(e => e.MemberOf == $"{subject.Namespace}.{subject.TypeName}")
            .ToList();

        var @namespace = subject.Namespace is not null 
            ? $"namespace {subject.Namespace};"
            : string.Empty;
        
        var builderExtensionCode = 
            $$"""
              // <auto-generated/> @{{DateTime.UtcNow}} @GroupExtensionsExecution.cs
              #nullable enable

              using Scribbly.Stencil;

              using Microsoft.AspNetCore.Builder;
              using Microsoft.AspNetCore.Http;
              using Microsoft.AspNetCore.Mvc;
              using Microsoft.AspNetCore.Routing;

              {{CreateUsingStatements(subject, endpoints)}}

              {{@namespace}}
              
              public static class {{subject.TypeName}}Extensions
              {
                  /// <summary>
                  /// Maps the endpoint group {{subject.TypeName}} to a endpoint builder with the routing prefix {{subject.TypeName}}.
                  /// </summary>
                  {{new StringBuilder().CreateGroupRegistrationMethodSignature(subject, builder)}}
                  {
                      {{new StringBuilder().CreateNewGroup(subject, builder)}}

                      var routeGroup = scribblyGroup.Map{{subject.TypeName}}(builder);
                      {{CreateEndpointMapping(endpoints, builder)}}
                      return routeGroup;
                  }
              }
              """;
        var groupName = subject.Namespace is null ? $"{subject.TypeName}" : $"{subject.Namespace}.{subject.TypeName}";
        context.AddSource($"Group.{groupName}.Extensions.g.cs", builderExtensionCode);
    }

    private static string CreateUsingStatements(TargetGroupCaptureContext groups, List<TargetMethodCaptureContext> endpoints)
    {
        var builder = new StringBuilder();
        var namespaces = new List<string?>(endpoints.Count() + 1) { groups.Namespace };

        namespaces.AddRange(endpoints.Select(e => e.Namespace));
        
        foreach (var name in namespaces.Distinct())
        {
            builder.AppendLine($"using {name};");
        }
        return builder.ToString();
    }
    
    private static string CreateEndpointMapping(List<TargetMethodCaptureContext> endpoints, BuilderCaptureContext? builderCtx)
    {
        var sb = new StringBuilder();
        sb.AppendLine();
        foreach (var endpoint in endpoints)
        {
            sb.Append("        routeGroup.").CreateEndpointMappingMethodInvocation(subject: endpoint, builderCtx);
            sb.AppendLine();
        }
        return  sb.ToString();
    }
}