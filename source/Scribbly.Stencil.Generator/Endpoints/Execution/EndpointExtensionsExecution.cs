using System.Dynamic;
using Scribbly.Stencil.Builder.Context;
using Scribbly.Stencil.Endpoints.Factories;

namespace Scribbly.Stencil.Endpoints;

using System.Text;
using Microsoft.CodeAnalysis;

public class EndpointExtensionsExecution
{
    /// <summary>
    /// Writes the captured information about the handle method as a Minimal API endpoint.
    /// </summary>
    /// <param name="context">Generator Context</param>
    /// <param name="captureContext">Captured endpoint combined with the endpoints Context</param>
    public static void Generate(SourceProductionContext context, (TargetMethodCaptureContext subject, BuilderCaptureContext? builderCtx) captureContext)
    {
        var (subject, builderCtx) = captureContext;
        
        var @namespace = subject.Namespace is not null 
            ? $"namespace {subject.Namespace};"
            : string.Empty;
        
        var builderExtensionCode = 
            $$"""
              // <auto-generated/> @{{DateTime.UtcNow}} @EndpointExtensionsExecution.cs
              #nullable enable

              using Scribbly.Stencil;

              using Microsoft.AspNetCore.Builder;
              using Microsoft.AspNetCore.Http;
              using Microsoft.AspNetCore.Mvc;
              using Microsoft.AspNetCore.Routing;

              {{@namespace}}
              
              public static class {{subject.TypeName}}{{subject.MethodName}}Extensions
              {
                  /// <summary>
                  /// Maps the endpoint {{subject.TypeName}} to an endpoint builder {{subject.MemberOf}} with the route {{subject.HttpMethod}} {{subject.HttpRoute}} 
                  /// </summary>
                  public static global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder {{new StringBuilder().CreateHandleExtensionMethodDeclaration(subject, builderCtx)}}
                  {
                      {{new StringBuilder().CreateNewEndpoint(subject, builderCtx)}}

                      var endpointConventionBuilder = scribblyEndpoint.{{subject.CreateEndpointMappingMethodName()}}(builder);

                      {{CreateConfigureInvocation(subject)}}
                      return builder;
                  }
              }
              """;
        var endpointName = subject.Namespace is null ? $"{subject.TypeName}.{subject.MethodName}" : $"{subject.Namespace}.{subject.TypeName}.{subject.MethodName}";
        context.AddSource($"Endpoint.{endpointName}.Extensions.g.cs", builderExtensionCode);
    }

    private static string CreateConfigureInvocation(TargetMethodCaptureContext subject)
    {
        if (!subject.IsConfigurable)
        {
            return string.Empty;
        }
        return subject.IsConfigurable 
            ? $"scribblyEndpoint.Configure{subject.MethodName}(endpointConventionBuilder);" 
            : string.Empty;
    }
}