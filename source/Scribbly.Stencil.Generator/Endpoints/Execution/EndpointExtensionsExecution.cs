using System.Dynamic;

namespace Scribbly.Stencil.Endpoints;

using System.Text;
using Microsoft.CodeAnalysis;
using Scribbly.Stencil.Endpoints.Context;

public class EndpointExtensionsExecution
{
    /// <summary>
    /// Writes the captured information about the handle method as a Minimal API endpoint.
    /// </summary>
    /// <param name="context">Generator Context</param>
    /// <param name="subject">Captured endpoint combined with the endpoints Context</param>
    public static void Generate(SourceProductionContext context, TargetMethodCaptureContext subject)
    {
        var @namespace = subject.Namespace is not null 
            ? $"namespace {subject.Namespace};"
            : string.Empty;
        
        var builderExtensionCode = 
            $$"""
              // <auto-generated/> @{{DateTime.UtcNow}}
              #nullable enable

              using Scribbly.Stencil;

              using Microsoft.AspNetCore.Builder;
              using Microsoft.AspNetCore.Http;
              using Microsoft.AspNetCore.Mvc;
              using Microsoft.AspNetCore.Routing;

              {{@namespace}}
              
              public static class {{subject.TypeName}}{{subject.MethodName}}Extensions
              {
                  /// <summary>
                  /// Maps the endpoint {{subject.TypeName}} to an endpoint builder {{subject.MemberOf}} with the route {{subject.HttpMethod}} {{subject.HttpRoute}} 
                  /// </summary>
                  public static global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder Map{{subject.TypeName}}(this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder builder)
                  {
                      var scribblyEndpoint = new global::{{subject.Namespace}}.{{subject.TypeName}}();

                      var endpointConventionBuilder = scribblyEndpoint.Map{{subject.TypeName}}(builder);

                      {{CreateConfigureInvocation(subject)}}
                      return builder;
                  }
              }
              """;
        var endpointName = subject.Namespace is null ? $"{subject.TypeName}.{subject.MethodName}" : $"{subject.Namespace}.{subject.TypeName}.{subject.MethodName}";
        context.AddSource($"Endpoint.{endpointName}.Extensions.g.cs", builderExtensionCode);
    }

    private static string CreateConfigureInvocation(TargetMethodCaptureContext subject)
    {
        return subject.IsConfigurable 
            ? $"        Configure{subject.MethodName}(endpointConventionBuilder);" 
            : string.Empty;
    }
}